<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Clean Runner Game</title>
  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css?family=Playfair+Display|Montserrat" rel="stylesheet" />
  <style>
    /* Root Colors from your palette */
    :root {
      --primary: #FADCD9;    /* Muted blush pink */
      --neutral: #FFF9F4;    /* Soft cream */
      --contrast: #FFFFFF;   /* Crisp white */
      --accent: #D4AF37;     /* Subtle gold */
      --secondary-text: #333;/* Slightly darker text for contrast */
    }

    body {
      margin: 0;
      padding: 0;
      background: var(--neutral);
      font-family: 'Montserrat', sans-serif;
      color: var(--secondary-text);
      /* Let it scroll if needed, but keep horizontal hidden */
      overflow-x: hidden;
    }

    h1, h2 {
      font-family: 'Playfair Display', serif;
      color: var(--primary);
      letter-spacing: 1px;
      margin: 0;
    }

    /* Centered container for instructions */
    #instructionScreen {
      position: fixed;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      background: var(--neutral);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 20px;
      z-index: 100;
    }

    #instructionScreen p {
      font-size: 1.1rem;
      margin-bottom: 20px;
    }

    button {
      font-family: 'Montserrat', sans-serif;
      background: var(--primary);
      border: 1px solid var(--accent);
      color: var(--contrast);
      padding: 10px 20px;
      margin: 5px;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.2s ease;
    }
    button:hover {
      transform: scale(1.05);
    }

    /* Game container - responsive box */
    #gameContainer {
      display: none; /* hidden until Start is clicked */
      width: 100%;
      min-height: 100vh;
      padding-top: 20px;
      box-sizing: border-box;
    }

    /* The “box” for the game – responsive and centered */
    #gameBox {
      max-width: 700px; /* a bit narrower so it fits on mobile screens nicely */
      width: 90%;       /* fallback for smaller screens */
      margin: 0 auto;
      background: var(--contrast);
      border: 2px solid var(--accent);
      border-radius: 12px;
      position: relative;
      overflow: hidden;
      padding: 20px;
      box-sizing: border-box;
    }

    /* Score & progress */
    #scoreBoard {
      font-size: 1rem;
      margin-bottom: 10px;
    }
    #progressBar {
      width: 100%;
      height: 6px;
      background: #eee;
      border-radius: 3px;
      margin-bottom: 10px;
      position: relative;
      overflow: hidden;
    }
    #progressFill {
      width: 0%;
      height: 100%;
      background: var(--accent);
      transition: width 0.3s ease;
    }

    /* Canvas: scaled down for mobile */
    #gameCanvas {
      display: block;
      width: 100%;
      height: auto;
      background: var(--neutral);
      border: 1px solid #ccc;
      margin: 0 auto;
    }

    /* Mobile Jump Button */
    #jumpButton {
      position: absolute;
      bottom: 20px;
      right: 20px;
      z-index: 5;
      padding: 15px 25px;
      font-size: 1rem;
      border-radius: 50px;
      background: var(--primary);
      border: 1px solid var(--accent);
      display: none; /* only displayed if mobile */
    }

    /* Popup Overlay */
    #popup {
      position: fixed;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      background: rgba(0,0,0,0.5);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 999;
    }

    #popupContent {
      background: var(--contrast);
      padding: 20px;
      border: 2px solid var(--primary);
      border-radius: 12px;
      text-align: center;
      max-width: 80%;
    }
    #popupContent p {
      margin-bottom: 15px;
      font-size: 1.2rem;
    }

    /* End Credits Screen */
    #credits {
      position: fixed;
      width: 100%;
      height: 100vh;
      background: #000;
      color: #fff;
      display: none;
      overflow: hidden;
      top: 0;
      left: 0;
      z-index: 1000;
    }
    #creditsContent {
      position: absolute;
      width: 100%;
      text-align: center;
      font-family: 'Playfair Display', serif;
      font-size: 1.5rem;
      line-height: 2;
      animation: scrollCredits 20s linear forwards;
      top: 100%;
    }
    @keyframes scrollCredits {
      from { top: 100%; }
      to { top: -200%; }
    }
  </style>
</head>
<body>
  <!-- Instruction Screen -->
  <div id="instructionScreen">
    <h1>Welcome to Your Run!</h1>
    <p>Jump over obstacles to avoid collisions. Use Spacebar on PC or tap the Jump button on mobile.</p>
    <button id="startButton">Start</button>
  </div>

  <!-- Main Game Container -->
  <div id="gameContainer">
    <div id="gameBox">
      <div id="scoreBoard">Obstacles Cleared: 0</div>
      <div id="progressBar">
        <div id="progressFill"></div>
      </div>
      <canvas id="gameCanvas" width="600" height="300"></canvas>
      <button id="jumpButton">Jump</button>
    </div>
  </div>

  <!-- Popup for messages -->
  <div id="popup">
    <div id="popupContent">
      <p id="popupMessage"></p>
      <button id="continueButton">Continue</button>
      <button id="restartButton" style="display:none;">Restart</button>
    </div>
  </div>

  <!-- End Credits Screen -->
  <div id="credits">
    <div id="creditsContent">
      <p>Trust me, it's u will like it</p>
      <p>Congratulations!</p>
      <p>blah blah</p>
      <p>blah blah</p>
      <p>blah blah</p>
      <p>blah blah</p>
      <p>blah blah</p>
      <p>blah blah</p>
    </div>
  </div>

  <!-- Audio for Jump -->
  <audio id="jumpSound" src="https://freesound.org/data/previews/331/331912_3248244-lq.mp3"></audio>

  <script>
    // Basic device detection for mobile jump button
    const isMobile = /Mobi|Android/i.test(navigator.userAgent);
    const jumpButton = document.getElementById('jumpButton');
    if (isMobile) jumpButton.style.display = 'block';

    // DOM elements
    const instructionScreen = document.getElementById('instructionScreen');
    const startButton = document.getElementById('startButton');
    const gameContainer = document.getElementById('gameContainer');
    const gameBox = document.getElementById('gameBox');
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const popup = document.getElementById('popup');
    const popupMessage = document.getElementById('popupMessage');
    const continueButton = document.getElementById('continueButton');
    const restartButton = document.getElementById('restartButton');
    const credits = document.getElementById('credits');
    const scoreBoard = document.getElementById('scoreBoard');
    const progressBar = document.getElementById('progressBar');
    const progressFill = document.getElementById('progressFill');

    // Game state variables
    let gameState = 'instructions'; // instructions, playing, paused, ended
    let animationId;
    const totalObstacles = 10;
    let currentObstacleIndex = 0;
    let obstacles = [];
    let gameSpeed = 4; // speed at which obstacles move
    const obstacleGap = 500; // 2.5x bigger than the old 200 => 500

    // Player
    const player = {
      x: 50,
      y: 260,  // on ground (300 - 40)
      width: 40,
      height: 40,
      vy: 0,
      gravity: 0.8,
      jumpForce: -14,
      isJumping: false,
      image: new Image(),
      jumpImage: new Image(),
      currentImg: null
    };
    player.image.src = 'runp.jpeg';  // normal
    player.jumpImage.src = 'jumpp.jpeg'; // jumping
    player.currentImg = player.image;

    // Obstacle messages
    const obstacleMessages = [
      "You're bigger than all the problems in life!",
      "Keep pushing forward!",
      "Every challenge makes you stronger!",
      "You're unstoppable, babe!",
      "Rise above the obstacles!",
      "Don't let fear hold you down!",
      "Your strength shines through!",
      "Bad dreams? You're more powerful than any nightmare!",
      "Embrace the journey, one leap at a time!",
      "Victory is yours, keep running!"
    ];

    /* ------------------ INITIALIZE & START ------------------ */
    startButton.addEventListener('click', () => {
      instructionScreen.style.display = 'none';
      gameContainer.style.display = 'block';
      gameState = 'playing';
      createObstacles();
      updateScore(0);
      requestAnimationFrame(gameLoop);
    });

    // Create obstacles with the bigger gap
    function createObstacles() {
      obstacles = [];
      let startX = canvas.width + 100;
      for (let i = 0; i < totalObstacles; i++) {
        obstacles.push({
          x: startX + i * obstacleGap,
          y: 260,       // ground level (300 - 40)
          width: 40,
          height: 40,
          message: obstacleMessages[i],
          passed: false
        });
      }
    }

    /* ------------------ GAME LOOP ------------------ */
    function gameLoop() {
      if (gameState !== 'playing') return;

      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw & update
      updatePlayer();
      drawPlayer();
      updateObstacles();
      drawObstacles();

      // Next frame
      animationId = requestAnimationFrame(gameLoop);
    }

    /* ------------------ PLAYER ------------------ */
    function updatePlayer() {
      // Apply gravity
      player.y += player.vy;
      player.vy += player.gravity;

      // If on ground
      if (player.y + player.height >= 300) {
        player.y = 300 - player.height;
        player.vy = 0;
        player.isJumping = false;
        player.currentImg = player.image;
      }
    }

    function drawPlayer() {
      if (player.currentImg.complete && player.currentImg.naturalWidth > 0) {
        ctx.drawImage(player.currentImg, player.x, player.y, player.width, player.height);
      } else {
        // fallback: a black square if images not found
        ctx.fillStyle = '#000';
        ctx.fillRect(player.x, player.y, player.width, player.height);
      }
    }

    // Jump logic
    function jump() {
      if (!player.isJumping) {
        player.vy = player.jumpForce;
        player.isJumping = true;
        player.currentImg = player.jumpImage;
        const jumpSound = document.getElementById('jumpSound');
        jumpSound.currentTime = 0;
        jumpSound.play();
      }
    }

    document.addEventListener('keydown', (e) => {
      if (gameState === 'playing' && e.code === 'Space') {
        jump();
      }
    });
    jumpButton.addEventListener('click', () => {
      if (gameState === 'playing') jump();
    });

    /* ------------------ OBSTACLES ------------------ */
    function updateObstacles() {
      if (currentObstacleIndex >= obstacles.length) return;

      obstacles.forEach(ob => {
        ob.x -= gameSpeed;
      });

      let ob = obstacles[currentObstacleIndex];
      // Check collision if bounding boxes overlap
      if (isCollision(player, ob)) {
        pauseGame(`You hit the obstacle!`, true); // collision popup
        currentObstacleIndex++;
        updateScore(currentObstacleIndex);
      }
      // Check if we've passed it
      else if (!ob.passed && ob.x + ob.width < player.x) {
        // If the player's bottom is above obstacle top => we jumped it
        // else we treat it as a collision
        // But for simplicity, we assume if we made it behind us, we jumped it
        ob.passed = true;
        pauseGame(ob.message, false); // motivational popup
        currentObstacleIndex++;
        updateScore(currentObstacleIndex);
      }
    }

    function drawObstacles() {
      obstacles.forEach(ob => {
        ctx.fillStyle = varOrDefault('--accent', '#D4AF37');
        ctx.fillRect(ob.x, ob.y, ob.width, ob.height);

        // Mark the obstacle with a question mark for style
        ctx.font = "10px Montserrat";
        ctx.fillStyle = "#333";
        ctx.fillText("?", ob.x + 12, ob.y + 25);
      });
    }

    // Basic bounding box collision
    function isCollision(a, b) {
      return (
        a.x < b.x + b.width &&
        a.x + a.width > b.x &&
        a.y < b.y + b.height &&
        a.y + a.height > b.y
      );
    }

    /* ------------------ POPUPS & STATE ------------------ */
    function pauseGame(msg, isCollision, isFinal=false) {
      gameState = 'paused';
      cancelAnimationFrame(animationId);

      popupMessage.innerText = msg;
      popup.style.display = 'flex';

      // If final
      if (isFinal) {
        continueButton.innerText = "Finish";
        restartButton.style.display = "none";
        continueButton.onclick = () => {
          popup.style.display = 'none';
          showCredits();
        };
      }
      else {
        continueButton.innerText = isCollision ? "Continue Anyway" : "Continue";
        restartButton.style.display = isCollision ? "inline-block" : "none";
        
        // If we’ve finished all obstacles, next is final
        if (currentObstacleIndex >= totalObstacles) {
          continueButton.innerText = "Finish";
          continueButton.onclick = () => {
            popup.style.display = 'none';
            showCredits();
          };
        }
        else {
          continueButton.onclick = resumeGame;
        }
      }
    }

    function resumeGame() {
      popup.style.display = 'none';
      gameState = 'playing';
      requestAnimationFrame(gameLoop);
    }

    restartButton.addEventListener('click', () => {
      window.location.reload();
    });

    /* ------------------ SCORE & PROGRESS ------------------ */
    function updateScore(index) {
      if (index > totalObstacles) index = totalObstacles;
      scoreBoard.innerText = `Obstacles Cleared: ${index}`;
      let progressPercent = (index / totalObstacles) * 100;
      progressPercent = Math.min(progressPercent, 100);
      progressFill.style.width = progressPercent + '%';
    }

    /* ------------------ END CREDITS ------------------ */
    function showCredits() {
      gameContainer.style.display = 'none';
      credits.style.display = 'block';
    }

    /* Helper to read CSS variable with fallback */
    function varOrDefault(variable, fallback) {
      const val = getComputedStyle(document.documentElement).getPropertyValue(variable);
      return val.trim() === '' ? fallback : val;
    }
  </script>
</body>
</html>
